import Control.Monad
import Data.List
import System.Environment
import System.IO
import System.FilePath
import System.Posix.Files
import System.Directory

main :: IO ()
main =
    do gitTag <- getEnv "GIT_DESCRIBE"
       synopsisSection <- getSection "Synopsis"
       descriptionSection <- getSection "Description"
       let me = "Emin Karayel <me@eminkarayel.de>"
           packageUrl = "https://github.com/ekarayel/sync-mht"
           baseSrc = "src/main/hs"
       moduleLines <- toModuleLines baseSrc
       writeFile "sync-mht.cabal" $ unlines $
           [ "-- This .cabal file was generated by src/build/hs/CabalTemplate.hs"
           , "name: sync-mht"
           , "version: " ++ gitTag
           , "synopsis: "
           ] ++ synopsisSection ++
           [ "description: "
           ] ++ descriptionSection ++
           [ "license: MIT"
           , "license-file: LICENSE"
           , "author: " ++ me
           , "maintainer: " ++ me
           , "package-url: " ++ packageUrl
           , "category: Utility"
           , "build-type: Simple"
           , "cabal-version: >=1.10"
           , "source-repository head"
           , "    type: git"
           , "    location: " ++ packageUrl
           , "source-repository this"
           , "    type: git"
           , "    tag: " ++ gitTag
           , "    location: " ++ packageUrl
           , "executable sync-mht"
           ] ++ (indent moduleLines) ++
           [ "    ghc-options: -Wall"
           , "    build-depends: "
           , "        base >=4.7 && <4.8"
           , "        , unix >=2.7 && <2.8"
           , "        , directory >=1.2 && <1.3"
           , "        , filepath >=1.3 && <1.4"
           , "        , process >=1.2 &&  <1.3"
           , "        , cryptohash >=0.11 && <0.12"
           , "        , byteable >=0.1 && <0.2"
           , "        , array >=0.5 && <0.6"
           , "        , containers >=0.5 && <0.6"
           , "        , text >=1.2 && <1.3"
           , "        , bytestring >=0.10 && <0.11"
           , "        , base16-bytestring >=0.1 && <0.2"
           , "        , cereal >= 0.4 && < 0.5"
           , "        , io-streams >= 1.2 && <1.3"
           , "        , transformers >= 0.4 && < 0.5"
           , "        , mtl >= 2.2 && < 2.3"
           , "    hs-source-dirs: " ++ baseSrc
           , "    default-language: Haskell2010"
           ]

_TAB_SIZE_ :: Int
_TAB_SIZE_ = 4

indent :: [String] -> [String]
indent = map ((replicate _TAB_SIZE_ ' ') ++)

getSection :: String -> IO [String]
getSection name =
    liftM
       ( indent
       . takeWhile (not . ("#" `isPrefixOf`))
       . drop 1
       . dropWhile (/= ("## " ++ name))
       . lines
       ) $ readFile "README.md"

data Module = Module { m_main :: Bool, m_name :: String }
    deriving Show

prepend :: String -> Module -> Module
prepend prefix m = m { m_name = prefix ++ "." ++ (m_name m) }

toModuleLines :: FilePath -> IO [String]
toModuleLines path =
    do mods <- findAllModules path
       let ([mainMod], otherMods) = partition m_main mods
       return $
           [ "main-is: " ++ m_name mainMod ++ ".hs"
           , "other-modules: " ] ++
           (indent $ map m_name otherMods)

findAllModules :: FilePath -> IO [Module]
findAllModules path =
    do pathComponents <- getDirectoryContents path
       liftM concat $ forM (filter (`notElem` [".",".."]) pathComponents) $ \pathComponent ->
          do let fullPath = path </> pathComponent
             status <- getFileStatus fullPath
             case () of
               () | isRegularFile status
                  , Just moduleName <- (fmap reverse (stripPrefix "sh." (reverse pathComponent))) ->
                   do moduleLines <- liftM lines $ readFile fullPath
                      return $ [
                          Module
                          { m_main = ["-- main module"] `isPrefixOf` moduleLines
                          , m_name = moduleName
                          } ]
                  | isDirectory status ->
                   liftM (map (prepend pathComponent)) $ findAllModules fullPath
                  | otherwise ->
                   return []

